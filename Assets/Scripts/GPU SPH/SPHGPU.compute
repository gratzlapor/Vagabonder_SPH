// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculateVariables
#pragma kernel CalculateForces
#pragma kernel CalculatePosition
#pragma kernel FluvialHeightGain
#pragma kernel FluvialHeightLost
#pragma kernel HeightSmoothing

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct particle
{
    float density;
    float pressure;
    float3 pressureForce;
    float3 viscosityForce;
    float3 acceleration;
    float3 velocity;
    float3 position;
    float starter;
};

struct boundaryParticle
{
    float3 position;
    float erodable;
};

//constants and variables
float pi;
float mass;
float boundaryMass;
float spacingMultiplier;
float radius;
float radius2;
float radius3;
float erosionRadius;
float boundaryRadius;
float boundaryRadius2;

float gasConstant;
float exponent;
float restDensity;
float fluidResistance;
float gravity;
float timeStep;
float friction;
float wind;

float smoothRadius;

float4 boxPosition;
float4 boxSize;

float4x4 _WorldToLocal;

int allParticlesCount;
uint wParticleCount;
uint bParticleCount;

StructuredBuffer<float4> startingPositions;


//array
RWStructuredBuffer<particle> Particles;
RWStructuredBuffer<boundaryParticle> boundaryParticles;



[numthreads(256, 1, 1)]
void CalculateVariables(uint3 id : SV_DispatchThreadID) // Density and Pressure
{   
    float densityF = float(0);
    float densityB = float(0);
    for (int i = 0; i < wParticleCount; i++)
    {
        float3 substract = Particles[id.x].position - Particles[i].position;
        float difference2 = dot(substract, substract);
        if (difference2 <= radius2) // if 0<r<h
        {
            densityF += mass * (315 / (64 * pi * pow(abs(radius), 9))) * pow(radius2 - difference2, 3);
        }  
    }
    for (int j = 0; j < bParticleCount; j++)
    {   
        float3 substract_ = Particles[id.x].position - boundaryParticles[j].position;
        float difference2_ = dot(substract_, substract_);
        if (difference2_ <= boundaryRadius2) // if 0<r<h
        {
            densityB += boundaryMass * (315 / (64 * pi * pow(abs(boundaryRadius), 9))) * pow(boundaryRadius2 - difference2_, 3);
        }
    }
    
    Particles[id.x].density = densityF + densityB;
    Particles[id.x].pressure = ((gasConstant * restDensity) / exponent) * (pow(Particles[id.x].density / restDensity, exponent) - 1);
}

[numthreads(256, 1, 1)]
void CalculateForces(uint3 id : SV_DispatchThreadID) // PressureForce and ViscosityForce (Vector3)
{
    float3 pressureForceF = float3(0, 0, 0);
    float3 pressureForceB = float3(0, 0, 0);
    float3 viscosityForce = float3(0, 0, 0);
    for (int i = 0; i < wParticleCount; i++)
    {
        float difference = distance(Particles[id.x].position, Particles[i].position);
        if (id.x != i && difference <= radius) // if 0<r<h
        {
            float3 direction = normalize(Particles[id.x].position - Particles[i].position); // r/|r|
            float3 gradW = -(45 / (pi * pow(radius, 6))) * (direction * pow(radius - difference, 2));
            pressureForceF += ((Particles[id.x].pressure / (Particles[id.x].density * Particles[id.x].density)) + Particles[i].pressure / (Particles[i].density * Particles[i].density)) * gradW;
            viscosityForce += mass * ((Particles[i].velocity - Particles[id.x].velocity) / Particles[i].density) * (45 / (pi * pow(radius, 6))) * (radius - difference);
        }
    }
    for (int j = 0; j < bParticleCount; j++)
    {
        float difference_ = distance(Particles[id.x].position, boundaryParticles[j].position);
        if (difference_ > 0 && difference_ <= boundaryRadius) // if 0<r<h
        {
            float3 direction = normalize(Particles[id.x].position - boundaryParticles[j].position); // r/|r|
            float3 gradW = -(45 / (pi * pow(boundaryRadius, 6))) * (direction * pow(boundaryRadius - difference_, 2));
            pressureForceB += boundaryMass * (Particles[id.x].pressure / (Particles[id.x].density * Particles[id.x].density)) * gradW;
        }
    }
    
    Particles[id.x].pressureForce = -mass * (pressureForceF + pressureForceB);
    Particles[id.x].viscosityForce = viscosityForce * fluidResistance;
}

[numthreads(256, 1, 1)]
void CalculatePosition(uint3 id : SV_DispatchThreadID)
{
    
    float3 externalForce = float3(0, gravity, wind);
    float3 allForces = float3(0,0,0);
    allForces = Particles[id.x].pressureForce + Particles[id.x].viscosityForce;
    Particles[id.x].acceleration = (allForces / Particles[id.x].density) +externalForce;
    
    float3 newVel;
    newVel = Particles[id.x].velocity + timeStep * Particles[id.x].acceleration;
    Particles[id.x].velocity = newVel * friction;
    
    // a falakat ne mozgassuk
    float3 newPos;
    newPos = Particles[id.x].position + timeStep * Particles[id.x].velocity;
    Particles[id.x].position = newPos;
    
    if (Particles[id.x].position.z > boxPosition.z + boxSize.z * 2.25)
    {
        Particles[id.x].starter = 0;
    }
    
    
    if (Particles[id.x].starter==1)
    {
        float3 boxP3 = float3(boxPosition.x, boxPosition.y, boxPosition.z);
        float3 boxS3 = float3(boxSize.x, boxSize.y*2, boxSize.z);
        float boundDamping = -float(0.5);
        float3 topRight = boxP3 + (boxS3 / 2);
        float3 bottomLeft = boxP3 - (boxS3 / 2);
    
        if (Particles[id.x].position.x - radius < bottomLeft.x)
        {
            Particles[id.x].velocity.x *= boundDamping;
            Particles[id.x].position.x = bottomLeft.x + radius;
        }

        if (Particles[id.x].position.y - radius < bottomLeft.y)
        {
            Particles[id.x].velocity.y *= boundDamping;
            Particles[id.x].position.y = bottomLeft.y + radius;
        }

        if (Particles[id.x].position.z - radius < bottomLeft.z)
        {
            Particles[id.x].velocity.z *= boundDamping;
            Particles[id.x].position.z = bottomLeft.z + radius;
        }

        if (Particles[id.x].position.x + radius > topRight.x)
        {
            Particles[id.x].velocity.x *= boundDamping;
            Particles[id.x].position.x = topRight.x - radius;
        }

        if (Particles[id.x].position.y + radius > topRight.y)
        {
            Particles[id.x].velocity.y *= boundDamping;
            Particles[id.x].position.y = topRight.y - radius;
        }   
    }
    else
    {
        if (Particles[id.x].position.y < 5 || Particles[id.x].position.y > 50)
        {
            Particles[id.x].position = float3(startingPositions[id.x].x, startingPositions[id.x].y, startingPositions[id.x].z);
            Particles[id.x].velocity *= 0.4;
            Particles[id.x].starter = 1;
        }

    }

}

[numthreads(278, 1, 1)]
void FluvialHeightGain(uint3 id : SV_DispatchThreadID)
{
    float posY = boundaryParticles[id.x].position.y;
    
    if (posY < 20)
    {
        posY += 0.000001;
    }
    
    boundaryParticles[id.x].position.y = posY;
    
}

[numthreads(203, 1, 1)]
void FluvialHeightLost(uint3 id : SV_DispatchThreadID)
{
    int counter = 0;
    float3 worldPos = boundaryParticles[id.x].position;

    float3 localPos = mul(_WorldToLocal, float4(worldPos, 1.0)).xyz;

        for (int j = 0; j < wParticleCount; j++)
        {
            float difference_ = distance(boundaryParticles[id.x].position, Particles[j].position);
            if (difference_ > 0 && difference_ <= erosionRadius) // if 0<r<h
            {
                if (localPos.y > -5 && Particles[j].pressure > 25 && length(Particles[j].velocity) > 7 && counter < 3 && boundaryParticles[id.x].erodable == 1)
                {
                    boundaryParticles[id.x].position.y -= 0.00001;
                }
            }
            if (difference_ > 0 && difference_ <= radius3) // if 0<r<h
            {
                counter++;
            }
        }
    //if (counter == 0)
    //{
    //    if (localPos.y < -3.5)
    //    {
    //        boundaryParticles[id.x].position.y += 0.000035;
    //    }
    //}
}

[numthreads(320, 1, 1)]
void HeightSmoothing(uint3 id : SV_DispatchThreadID)
{
     float sum = 0;
     int count = 0;

        for (int i = 0; i < bParticleCount; i++)
        {
            float2 diffXZ = boundaryParticles[i].position.xz - boundaryParticles[id.x].position.xz;
            float d2 = dot(diffXZ, diffXZ);

            if (d2 <= smoothRadius)
            {
                sum += boundaryParticles[i].position.y;
                count++;
            }
        }

        float avg = sum / max(count, 1);

        boundaryParticles[id.x].position.y = lerp(boundaryParticles[id.x].position.y, avg, 0.075);
}